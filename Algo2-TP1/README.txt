Al programa, al correrlo, deberas pasarle por linea de comando 2 archivos distintos. El primer archivo que deberas pasar es el que contenga a los pokemon del arrecife. Despues deberas pasarle el archivo en el que se guardaran los pokemon del acuario. Si no pasas 2 archivos el programa te avisara. Si el archivo del arrecife esta mal pasado o no existe el programa te avisara.
Lo que hara el programa sera mover los pokemon del archivo del arrecife hacia un struct llamado arrecife. De ahi, a los pokemon que cumplan ciertas condiciones se los trasladara a otro struct llamado al acuario (este ultimo proceso se realizara varias veces con distintas condiciones) y se imprimira cada vez que se trasladen, los pokemon que vayan quedando en el arrecife. Por ultimo, los pokemon que esten en el acuario se guardaran en un archivo (el segundo archivo que hayas pasado por linea de comando).

Para compilar el programa debera ejecutar en su terminal el siguiente comando: "gcc *.c -Wall -Werror -Wconversion -std=c99 -o evento_pesca" (teniendo en cuenta que esta se encuentre en la carpeta donde haya guardado el archivo del programa).

Para ejecutar el programa, una vez compilado, debera escribir en su terminal la linea "./evento_pesca" y despues de esta linea deberas agregar primero el archivo de los pokemon del arrecife y despues el archivo en el que se guardaran los pokemon del acuario. La linea quedara asi: "./evento_pesca   
(archivo_arrecife.txt) (archivo_acuario.txt)". Tambien podras ejecutarlo con valgrind con la siguiente linea: "valgrind --leak-check=full --track-origins=yes --show-reachable=yes ./evento_pesca (archivo arrecife.txt) (archivo acuario.txt)"

Para la realizacion de este trabajo se utilizaron los punteros que son un tipo de dato que almacenan especificamente direcciones de memoria. Cada puntero tiene asignado un tipo de dato especifico, quiere decir que un puntero que almacene la direccion de memoria de un entero, solo podra almacenar la direccion de memoria de un entero. Los punteros pueden servir para acceder a traves de su direccion de memoria a un tipo de dato y modificarlo.

Los punteros ademas, tienen operadores especificos. Esta el operador "*" al cual, si se le asigna a un puntero (asumiendo que este esté inicializado), recorrerá a la posicion de memoria que almacena el puntero y devolverá lo que sea que se encuentre en esa posición de memoria. Tambien existe el operador "&" el cual, si se aplica a cualquier tipo de dato, este nos devolvera la posición de memoria del mismo. Ambos son operadores unarios, es decir, que solo se necesita un elemento para poder aplicarlos.

Tambien se uso en este trabajo los punteros a funciones. Un puntero a funcion es (como lo dice su nombre y la definicion de puntero) un puntero que contiene una posicion de memoria que lleva a una funcion. Tener los punteros a funciones trae una gran cantidad de ventajas ya que nos permite: utilizar funciones como elementos de un vector, mandar funciones como parametros a otra funcion y ser devueltos por otras funciones. 

Existen ademas, las funciones malloc y realloc. "malloc" recibe como parametro un entero sin signo que representa un tamaño (en bytes) y lo que hace es reservar espacio en el heap (tanto espacio como el tamaño que recibio como parametro) y devuelve la posicion de memoria del primer byte de todos los que reservó. "realloc" recibe como parametros primero un puntero y despues un entero sin signo que representa el tamaño (en bytes) y lo que hace es modificar el tamaño de la memoria resercada anteriormente con un "malloc" reservando tantos bytes como la cantidad que recibio como 2do parametro, al igual que "malloc", "realloc" devuelve la direccion de memoria del primer byte reservado. Sin embargo, utilizar estas funciones a la ligera lleva un riesgo; siempre que se utiliza un malloc o un realloc se debe liberar la memoria reservada con la funcion "free" que recibe como parametro un puntero y lo que hace es liberar la memoria que haya sido reservada anteriormente con un "malloc" o "realloc". La no utilizacion de "free" puede resultar en los llamados "memoty leaks" puesto que, la memoria reservada, al finalizar el programa no muere y se queda ahi hasta que se reinicie la computadora, si esto ocurre muchas veces, la memoria se agotara y pasaran cosas malas.
